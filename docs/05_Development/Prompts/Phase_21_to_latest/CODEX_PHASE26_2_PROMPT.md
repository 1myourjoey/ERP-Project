# Phase 26_2: 결성예정 워크플로 자동 생성 복구 및 GP 출자 데이터 연동

> **Priority:** P0

---

## Table of Contents

1. [Part 1 — 신규 조합 '결성예정' 시 관련 워크플로 자동 생성 기능 복구](#part-1)
2. [Part 2 — GP 출자금 총약정액 기준 자동 계산 및 수정 로직 구현](#part-2)
3. [Part 3 — 조합 생성 완료 트랜잭션 시 GP의 LP(출자자) 목록 자동 편입](#part-3)
4. [Files to create / modify](#files-to-create--modify)
5. [Acceptance Criteria](#acceptance-criteria)
6. [구현 주의사항 (Computer Science Rules)](#구현-주의사항-computer-science-rules)

---

## 현재 상태 및 문제점 분석

조합(Fund)을 신규 등록하는 생성 폼(Create Modal) 단계에서 누락된 자동화 로직과 데이터 파편화를 복구합니다.

**주요 문제점:**
1. **유실된 결성 워크플로 자동 생성:** 과거에는 펀드 상태를 `결성예정(Planned)`으로 두고 생성하면 자동으로 '결성 관련 워크플로우'가 배정되어 대기 상태로 파이프라인에 꽂히던 기능이 있었으나, 리팩토링이나 버전 업 과정에서 유실되었습니다.
2. **GP 출자금액 반복 수기 입력:** 조합 관리의 첫 번째 카드로 들어가는 고유계정(GP Entity)에 대해, 보통 업계 관행인 **'총 약정액 대비 1% 의무출자'**가 폼 단에서 자동 계산되지 않아 사용자가 값을 매번 손으로 쳐야 하는 불편함이 있습니다.
3. **GP의 LP 목록 누락:** 시스템상 GP(고유계정) 역시 해당 펀드의 가장 1번 출자자(LP)로 등록되어야 하는데, 조합 정보에는 등록이 될지언정 `lps` 테이블(하단 LP 목록)에는 자동 Insert되지 않아 동일 데이터를 중복으로 또 생성해야 하는 불상사가 존재합니다.

이 단계는 **프론트엔드의 유려한 상태 연계(Controlled State)**, **백엔드의 생성 트랜잭션 생명주기 통일**에 초점을 둡니다.

---

## Part 1 — 신규 조합 '결성예정' 시 관련 워크플로 자동 생성 기능 복구

### 1-A. 백엔드 조합 생성 엔드포인트 내 로직 재점검
- **목표:** `/api/funds/` (POST, 조합 생성) API가 호출될 때, 클라이언트가 넘긴 페이로드(Payload)의 `status`가 '결성예정' 혹은 결성 관련 상태를 띈다면, 기존에 만들어둔 워크플로 템플릿('조합 결성' 카테고리 등) 중 기본(Default) 값을 하나 찾아와 자동으로 인스턴스화(`WorkflowInstance`) 시킬 것.
- 인스턴스화된 후, 파이프라인을 조회했을 때 펀드의 이름(예: `[보안1호] 결성 워크플로 단계`)을 달고 대기 상태에 온전히 들어와야 합니다.

---

## Part 2 — GP 출자금 총약정액 기준 자동 계산 및 수정 로직 구현

### 2-A. 프론트엔드 React Hook 폼 값(Value) 동기화
- 신규 조합 추가 폼(`AddFundModal` 또는 `FundForm`)에서 **`총 약정액(Target Amount / Commitment Amount)`** Input 창에 사용자가 숫자를 기입할 때 이벤트를 캐치(Catch)합니다.
- `onChange` 또는 `useEffect`를 활용하여, **총 약정액 * 0.01 (1%)** 결과를 도출하고 **`GP 출자금`** Input 창에 `value`로 바인딩(SetState) 시킵니다.
- 단, 자동 연산이 실행된 직후라도 사용자가 원한다면 `GP 출자금` Input 박스에 커서를 올려 임의의 숫자로 수정(Override)할 수 있어야 합니다. (읽기 전용이 절대 아님)

---

## Part 3 — 조합 생성 완료 트랜잭션 시 GP의 LP(출자자) 목록 자동 편입

### 3-A. 원자적 트랜잭션(Atomic Transaction)을 통한 LP 자동 인서트
- 폼 요소에서 넘어온 정보는 최소 3가지로 뻗어나가 DB에 저장되어야 합니다.
  1. `Fund` 테이블 생성
  2. `Workflow` 테이블 생성 (Part 1 조건 부합 시)
  3. **`LP` 테이블 생성 (신규)**: `GP`로서의 역할을 부여받을 레코드 추가.
- 백엔드에서 Fund를 생성하고 방금 나온 `fund_id`를 가져와, 새로 만들 `LP` 인스턴스에 주입합니다.
  - LP의 `name` = 선택한 고유계정(GP Entity)의 이름과 동일하게 구성 (예: (주)브이온)
  - LP의 `type` = 'GP' 혹은 시스템이 GP를 식별하는 Enum 값
  - LP의 `commitment_amount` = 프론트 측에서 계산/수정되어 넘어온 **`GP 출자금`** 파라미터 값 매핑.
- 이 세 가지 작업은 단일 DB 트랜잭션 통로에서 실행(`db.commit()` 은 모든 생성 코드가 끝난 1번만)되며, 중간에 하나라도 깨지면 조합 자체의 생성이 롤백되어 찌꺼기가 남지 않게 설계해야 합니다.

---

## Files to create / modify

| # | Type | File | Changes |
|---|------|------|---------|
| 1 | **[MODIFY]** | `frontend/src/components/fund/...` (가칭: `FundFormModal.tsx` 조합생성 모달) | 총약정액 입력 시 GP 출자금 1% 자동 계산 및 양방향 State 수정 가능 로직 삽입 |
| 2 | **[MODIFY]** | `backend/routers/funds.py` | POST 로직에 Workflow 생성(status='결성예정' 판단) 및 LP 레코드(`type='GP'`) 강제 Insert 트랜잭션 구현 |
| 3 | **[MODIFY]** | `backend/schemas/fund.py` | 프론트로부터 넘어오는 `gp_commitment_amount` (GP 출자금) 파라미터를 받을 수 있도록 스키마 필드 확장 (없는 경우) |

*(코덱스는 위 가이드뿐만 아니라 스스로 코드베이스를 `grep_search`하여 정확한 경로와 파일들, 네이밍을 특정하고 작업해야 합니다.)*

---

## Acceptance Criteria

- [ ] AC-01: 프론트엔드의 조합 신규 등록 모달에서 '총 약정금액'을 `100,000,000` 로 입력할 경우, 키보드 입력이 끝남과 동시에 'GP 출자금' 칸에 `1,000,000` 값(1%)이 자동으로 기입된다.
- [ ] AC-02: AC-01의 자동 연산 이후, 사용자가 지우거나 임의로 `2,000,000`을 입력하면 GP 출자금 칸은 해당 커스텀 수정 값으로 유지되며 백엔드에 전송된다.
- [ ] AC-03: 조합 등록 시 상태 콤보박스를 `결성예정(Planned)`으로 선택하고 생성을 치면, 조합 생성과 동시에 `[해당 조합명]`을 보유한 결성 관련 워크플로우 카드가 파이프라인의 '대기중' 열에 자동으로 렌더링된다.
- [ ] AC-04: 조합 생성을 마친 뒤 방금 만든 조합의 상세 개요(`FundDetailPage`)에 접속하고 하단의 출자자(LP) 리스트를 펼치면, 사용자가 따로 하나씩 추가하지 않았음에도 이미 데이터베이스상 1순위로 '고유계정(GP명)/타입:GP/약정액:입력한 GP출자금' 정보가 담긴 LP 로우(Row)가 들어가 있다.

---

## 구현 주의사항 (Computer Science Rules)

1. **Transaction Atomicity:** 백엔드 `funds.py` 에 엮이는 3가지 생성 로직(Fund, Workflow, LP) 중 어느 하나라도 에러(예: 템플릿 미존재로 인한 Key Error 등)가 나면 `db.rollback()`이 선언되어 DB에 반쪽짜리 데이터가 남는 일이 절대 없어야 합니다.
2. **NaN 및 타입 강제화 이슈 방어:** 프론트 단에서 사용자가 입력하는 '총 약정액'은 천 단위 콤마(,)가 찍히는 텍스트일 확률이 높습니다. `1%` 계산 시 숫자 필터를 거치게 하여 `NaN`이나 `Infinity` 같은 값이 뜨면서 렌더링 붕괴(Crash)를 일으키지 않도록 사전에 숫자로 파싱(`parseInt`, `parseFloat`, `.replace(/,/g,'')`)하는 공학적 방어를 필수화해야 합니다.
3. **GP의 단일성 식별 보장 (Idempotency 등):** 해당 조합이 한 번 생성된 이후 수정(PUT) 작업으로 다시 찔렸을 때, `LP` 테이블에 `GP`가 무한 복제되어 이중 생성(Duplicate Record)되지 않도록, 백엔드는 생성(Create) 컨텍스트에서만 GP를 꽂을지 아니면 `gp_entity_id`가 이미 연결되어있는지 검증하는 방어 코드를 달면 안정성이 올라갑니다.
